/* 3rd party imports */
import fs from 'fs';
import path from 'path';
import he from 'he';
import fxp from 'fast-xml-parser';
import { Service, Inject } from 'typedi';

/* 1st party imports - Services */
import { DatabaseService } from '@/database';
import { SourceService } from '@/services/source';
import { MediaService } from '@/services/media';

/* 1st party imports */
import { extension_whitelist } from '@/common';

export interface ScanSQL {
	scan_id: string;
	source_resource_id: string;
	start_timestamp: number;
	end_timestamp: number | null;
	changes: number | null;
}

interface XMLMap {
	path: string;
	children: string[];
}

/** Represents a file that was changed (added or deleted) and its path.
 */
interface Diff {
	/** Name of the file, e.g 'nggyu.mp3' */
	name: string;
	/** Directory path to the file from the root dir (XML root, not FS root), e.g /MyMusic/RickAstley */
	path: string;
	/** How it was changed, either 'added' or 'deleted' */
	change: 'added' | 'deleted';
}

/** Takes a path and returns an XML representation of its tree, does not
 *  include hidden files.
 *  Schema: <dir name><file name/></dir>.
 */
const treeToXML = async (root_path: string, extension_whitelist: string[]): Promise<string> => {	
	root_path = path.normalize(root_path);

	const files = await fs.promises.readdir(root_path);
	let result = `<dir name="${he.encode(path.basename(root_path))}">`;

	/* If the directory is empty or hidden, return empty string */
	if (files.length === 0 || path.basename(root_path)[0] === '.')
		return '';

	for (const file of files)
	{
		const file_full_path = path.join(root_path, file);

		const file_xml_item = await fs.promises.stat(file_full_path)
			.then(async (stat) => {
				if (file[0] == '.')
					return null; // Ignore hidden files / dirs
				if (stat?.isDirectory())
					return await treeToXML(file_full_path, extension_whitelist); // Recurse into subdirectory
				else if (extension_whitelist.includes(path.extname(file).toLowerCase()))
					return `<file name="${he.encode(path.basename(file))}"/>`; // Is a file, and extension is whitelisted
				else
					return null;
			});
		
		result = file_xml_item ? result + file_xml_item : result;
	}

	return result + '</dir>';
};

/** Creates a diff array between two path XMLs generated by treeToXML.
 */
const getXMLDiff = (lhs: string | null, rhs: string | null): Diff[] => {
	if (lhs === rhs) return [];
	
	lhs = lhs ? lhs : '<dir name="/"></dir>';
	rhs = rhs ? rhs : '<dir name="/"></dir>';

	/** Converts arrayMode fast-xml-parser XML object into map of the values (dir and file tags) */
	const buildMap = (element: any, path: string, map: XMLMap[] = []): XMLMap[] => {
		/* The current map directory we're working on */
		const index = map.push({path: path, children: []});

		/* Loop through each property of the directory tag obj, should only contain dir and file tags */
		for (const key of Object.keys(element)) {
			if (key === 'dir')
			{
				/* Recurse into child directory, messy due to the nature of fxp arrayMode objects */
				for (const dir of element[key])
					if (dir) buildMap(dir, `${path}/${dir.name}`, map);
			}
			else if (key === 'file')
			{
				/* Loop through all the files in the files obj (gets all file tags) */
				for (const file of element[key])
					if (file) map[index - 1].children.push(file.name);
			}
		}

		return map;
	};

	/** Compares two XML maps produced by buildMap, returning array of the differences. */
	const diffMaps = (newMap: XMLMap[], oldMap: XMLMap[], secondPass?: boolean): Diff[] => {
		let changes: Diff[] = [];

		for (let i = 0; i < oldMap.length; i++)
		{
			const newMapIndex = newMap.findIndex(element => {
				return element.path === oldMap[i].path ? true : false;
			});

			if (newMapIndex >= 0)
			{
				/* Compare children */
				for (const child of oldMap[i].children) {
					if (!newMap[newMapIndex].children.includes(child)) {
						changes.push({
							name: child,
							path: oldMap[i].path,
							change: secondPass ? 'deleted' : 'added',
						});
					}
				}
			}
			else
			{
				/* If the element (dir) cannot be found in the newMap, all its children must not exist */
				for (const child of oldMap[i].children)
				{
					changes.push({
						name: child,
						path: oldMap[i].path,
						change: secondPass ? 'deleted' : 'added',
					});
				}
			}
		}

		/* Recurse function, getting elements that have been deleted */
		if (!secondPass)
			changes = changes.concat(diffMaps(oldMap, newMap, true));
		
		return changes;
	};

	const fxpOptions =
	{
		ignoreAttributes : false,
		attributeNamePrefix: '',
		arrayMode: true,
		attrValueProcessor: (val: string): string => he.decode(val, {isAttributeValue: true}),
		tagValueProcessor: (val: string): string => he.decode(val),
		trimValues: true,
	};

	const lhsParsed = fxp.parse(lhs, fxpOptions);
	const rhsParsed = fxp.parse(rhs, fxpOptions);

	const lhsMap = buildMap(lhsParsed.dir[0], `/${lhsParsed.dir[0].name}`);
	const rhsMap = buildMap(rhsParsed.dir[0], `/${rhsParsed.dir[0].name}`);

	return diffMaps(lhsMap, rhsMap);
};

@Service('scan.service')
export class ScanService {

	@Inject('database.service')
	private dbSvc: DatabaseService;

	@Inject('source.service')
	private srcSvc: SourceService;

	@Inject('media.service')
	private mediaSvc: MediaService;

	getScan(scan_id: string): ScanSQL | null {
		const scan = this.dbSvc.prepare(`
		SELECT scan_id source_resource_id start_timestamp end_timestamp changes
		FROM Scan
		WHERE scan_id = $scan_id
		`).get({scan_id}) as ScanSQL | undefined;

		return scan || null;
	}

	getScans(source_resource_id: string): ScanSQL[] | null {
		const scans = this.dbSvc.prepare(`
		SELECT scan_id source_resource_id start_timestamp end_timestamp changes
		FROM Scan
		WHERE source_resource_id = $source_resource_id
		`).all({source_resource_id}) as ScanSQL[];

		return scans.length > 0 ? scans : null;
	}

	getLatestScan(source_resource_id: string): ScanSQL | null {
		const scan = this.dbSvc.prepare(`
		SELECT scan_id source_resource_id start_timestamp end_timestamp changes
		FROM Scan
		WHERE source_resource_id = $source_resource_id
		ORDER BY start_timestamp DESC
		LIMIT 1
		`).get({source_resource_id}) as ScanSQL | undefined;

		return scan || null;
	}

	scanUnderway(source_resource_id: string): boolean {
		const latest_scan = this.getLatestScan(source_resource_id);

		if (!latest_scan || !latest_scan.end_timestamp)
			return true;
		
		return false;
	}

	checkLatestScanValidity(source_resource_id: string): boolean {
		const latest_scan = this.getLatestScan(source_resource_id);

		if (!latest_scan)
			return true;

		const process_start: Date = new Date();
		process_start.setTime(process_start.getTime() - process.uptime() * 1000);

		if (!latest_scan.end_timestamp && latest_scan.start_timestamp < process_start.getTime() / 1000)
			return false;

		return true;
	}
	
	/** Scans the given source for media.
	 */
	async scanSource(source_resource_id: string): Promise<void> {
		console.info('Starting source scan.');

		const source = this.srcSvc.getSourceByID(source_resource_id);

		if (!source)
			return;

		const newXMLTree = await treeToXML(source.path, extension_whitelist);
		const xmlDiff = getXMLDiff(source.xml_tree, newXMLTree);

		console.log('newXMLTree: ', newXMLTree);
		
		xmlDiff.forEach(({change, name, path}) => {
			if (change === 'added')
				this.mediaSvc.addMedia(name, path, source);
			else
				this.mediaSvc.removeMedia(name, path, source);
		});

		this.dbSvc.prepare(`
		UPDATE Source
		SET
			xml_tree = ?
		WHERE
			resource_id = ?
		`).run(newXMLTree, source_resource_id);

		console.info('Finished scanning source.');
	}
}